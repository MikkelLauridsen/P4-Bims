#-------------------------------------------------------------------
#Utility types
#-------------------------------------------------------------------

type Map<k,v> = {
    | Node (k, v, Map, Map)
    | Nil
}

#-------------------------------------------------------------------
#AST types
#-------------------------------------------------------------------

type NumeralNode = {
    | NumeralNode String
}

type VarNode = {
    | VarNode String
}

type BoolExprNode = {
    | ComparisonNode (ArithExprNode, ArithExprNode)
    | LessThanNode (ArithExprNode, ArithExprNode)
    | GreaterThanNode (ArithExprNode, ArithExprNode)
    | NotNode BoolExprNode
    | AndNode (BoolExprNode, BoolExprNode)
    | OrNode (BoolExprNode, BoolExprNode)
    | BoolParenNode BoolExprNode
}

type ArithExprNode = {
    | NumExprNode NumeralNode
    | VarExprNode VarNode
    | AddExprNode (ArithExprNode, ArithExprNode)
    | MultExprNode (ArithExprNode, ArithExprNode)
    | SubExprNode (ArithExprNode, ArithExprNode)
    | ArithParenNode ArithExprNode
}

type StatementNode = {
    | AssignmentNode (VarNode, ArithExprNode)
    | SkipNode
    | CompositeNode (StatementNode, StatementNode)
    | IfNode (BoolExprNode, StatementNode, StatementNode)
    | WhileNode (BoolExprNode, StatementNode)
    | PrintNode ArithExprNode
}

#-------------------------------------------------------------------
#JVM types
#-------------------------------------------------------------------

#https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.1
type ClassFile = { 
    | ClassFile (
        [Int],          #magicNumber
        Int,            #versionMinor
        Int,            #versionMajor
        [PoolConstant], #constantPool
        Int,            #accessFlags
        Int,            #thisClass
        Int,            #superClass
        [Int],          #interfaces
        [FieldInfo],    #fields
        [MethodInfo],   #methods
        [AttributeInfo] #attributes
    )
}

#https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4
type PoolConstant = { 
    | StringConstant String
    | IntegerConstant Int
    | ClassRef Int
    | StringRef Int
    | FieldRef (Int, Int)
    | MethodRef (Int, Int)
    | NameAndType (Int, Int)
}

#https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.5
type FieldInfo = {
    | FieldInfo (
        Int,            #access flags
        Int,            #name
        Int,            #descriptor
        [AttributeInfo] #attributes
    )
}

#https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.6
type MethodInfo = { 
    | MethodInfo (
        Int,            #access flags
        Int,            #name
        Int,            #descriptor
        [AttributeInfo] #attributes
    )
}

#https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.3
type ExceptionInfo = {
    | ExceptionInfo (
        Int, #start pc
        Int, #end pc
        Int, #handler pc
        Int  #catch type
    )
}

#https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7
#https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.3
type AttributeInfo = {
    | AttributeInfo (
        Int,  #name
        [Int] #info
    )
    | CodeAttributeInfo (
        Int,              #name
        Int,              #maxStack
        Int,              #maxLocals
        [JVMInstruction], #code
        [ExceptionInfo],  #exceptions
        [AttributeInfo]   #attributes
    )
}

type JVMInstruction = {
    | JVMiconst_0           # Push integer 0 onto stack
    | JVMiconst_1           # Push integer 1 onto stack
    | JVMldc Int            # Push constant from cp onto stack
    | JVMldc_w Int          # Push constant from cp onto stack (wide index)
    | JVMiload Int          # Push integer from local variable onto stack
    | JVMaload_0            # Push reference from cp onto stack
    | JVMistore Int         # Store top of stack to local variable
    | JVMiadd               # Add two numbers on stack
    | JVMisub               # Subtract two numbers on stack
    | JVMimul               # Multiply two numbers on stack
    | JVMif_icmpeq Int      # Jump if equal
    | JVMif_icmpne Int      # Jump if not equal
    | JVMif_icmplt Int      # Jump if less than
    | JVMif_icmpgt Int      # Jump if greater than
    | JVMgoto Int           # Jump to
    | JVMreturn             # Return from method
    | JVMgetstatic Int      # Push static field onto stack
    | JVMinvokevirtual Int  # Invoke virtual method
    | JVMinvokespecial Int  # Invoke special method (used for constructor)
}

    
#-------------------------------------------------------------------
#Utility functions
#-------------------------------------------------------------------

var bind::(Map<k,v> -> (k -> (v -> Map<k,v>))) = 
map => {
    key => {
        value => {
            match map {
                | Nil -> Node (key, value, Nil, Nil)
                | Node (key', value', map1', map2') -> 
                case {
                    | key == key' -> Node (key, value, map1', map2')
                    | key < key'  -> Node (key', value', (bind map1' key value), map2')
                    | key > key'  -> Node (key', value', map1', (bind map2' key value))
                }
            }
        } 
    }
}

var lookup::(Map<k,v> -> (k -> Maybe<v>)) = 
map => {
    key => {
        match map {
            | Nil -> Nothing
            | Node (key', value', map1', map2') ->
            case {
                | key == key' -> Just value'
                | key < key'  -> lookup map1' key
                | key > key'  -> lookup map2' key
            }
        }
    }
}

var writes::(String -> (File* -> (Bool, File*))) = 
s => {
    f => {
        match s {
            | []     -> (true, f)
            | (c:cs) -> 
                let (succ, f') = write c f in (
                    case {
                    | succ == true -> (writes cs f')
                    | ?            -> (false, f') 
                }
            )
        }
    }
}

var length::([a] -> Int) = 
l => {
    match l {
        | []     -> 0
        | (c:cs) -> 1 + length cs
    }
}

var map::((a -> b) -> ([a] -> [b])) = 
fun => {
    lst => {
        match lst {
            | [] -> []
            | (x:xs) -> ((fun x) : (map fun xs))
        }
    }
}

var concat::([[a]] -> [a]) = 
lst => {
    match lst {
        | [] -> []
        | (x:xs) -> x ++ (concat xs) 
    }
}

#-------------------------------------------------------------------
#JVM
#-------------------------------------------------------------------

var getByte::(Int -> (Int -> Char)) = 
b => {
    num => {
        i2c (num b>> (8 * b) b& 0xFF)
    }
}

var getBytes::(Int -> (Int -> [Char])) = 
c => {
    num => {
        case {
            | c == 0 -> []
            | ? -> (getByte (c - 1) num : getBytes (c - 1) num)
        }
    }
}

var uint8ToBytes::(Int -> [Char]) = getBytes 1
var uint16ToBytes::(Int -> [Char]) = getBytes 2
var uint32ToBytes::(Int -> [Char]) = getBytes 4

var int16ToBytes = uint16ToBytes

var tableToBytes::((a -> [Char]) -> ([a] -> [Char])) = 
f => { 
    l => { concat (map f l) }
}

var poolConstantToBytes::(PoolConstant -> [Char]) = 
pc => {
    match pc {
        | StringConstant str     -> uint8ToBytes  1 ++ uint16ToBytes (length str) ++ str
        | IntegerConstant i      -> uint8ToBytes  3 ++ uint32ToBytes i
        | ClassRef si            -> uint8ToBytes  7 ++ uint16ToBytes si
        | StringRef si           -> uint8ToBytes  8 ++ uint16ToBytes si
        | FieldRef (c, ntd)      -> uint8ToBytes  9 ++ uint16ToBytes c ++ uint16ToBytes ntd
        | MethodRef (c, ntd)     -> uint8ToBytes 10 ++ uint16ToBytes c ++ uint16ToBytes ntd
        | NameAndType (nsi, tdi) -> uint8ToBytes 12 ++ uint16ToBytes nsi ++ uint16ToBytes tdi
    }
}

#todo last
var fieldToBytes::(FieldInfo -> [Char]) = field => {
    []
}


var methodToBytes::(MethodInfo -> [Char]) = method => {
    match method {
        | MethodInfo (accessFlags, name, descriptor, attributes) ->
            uint16ToBytes accessFlags ++
            uint16ToBytes name ++
            uint16ToBytes descriptor ++
            uint16ToBytes (length attributes) ++
            tableToBytes attributeToBytes attributes
    }
}

var attributeToBytes::(AttributeInfo -> [Char]) = attribute => {
    match attribute {
        | AttributeInfo (name, info) -> [] #todo last
        | CodeAttributeInfo (name, maxStack, maxLocals, code, exceptions, attributes) ->
            let codeBytes = tableToBytes getInstructionBytes code in (
                uint16ToBytes name ++
                uint32ToBytes (
                    12 +
                    length codeBytes +
                    length exceptions +
                    length attributes
                ) ++
                uint16ToBytes maxStack ++
                uint16ToBytes maxLocals ++
                uint32ToBytes (length codeBytes) ++
                codeBytes ++
                uint16ToBytes (length exceptions) ++
                tableToBytes exceptionToBytes exceptions ++
                uint16ToBytes (length attributes) ++
                tableToBytes attributeToBytes attributes
            )
    }
}

#todo last
var exceptionToBytes::(ExceptionInfo -> [Char]) = exception => {
    []
}


var getClassBytes::(ClassFile -> [Char]) = class => {
    match class {
        | ClassFile (magicNumber, versionMinor, versionMajor, constantPool, accessFlags, 
        thisClass, superClass, interfaces, fields, methods, attributes) ->
            tableToBytes  uint8ToBytes magicNumber ++
            uint16ToBytes versionMinor ++
            uint16ToBytes versionMajor ++
            uint16ToBytes ((length constantPool) + 1) ++
            tableToBytes  poolConstantToBytes constantPool ++
            uint16ToBytes accessFlags ++
            uint16ToBytes thisClass ++
            uint16ToBytes superClass ++
            uint16ToBytes (length interfaces) ++
            tableToBytes  uint16ToBytes interfaces ++
            uint16ToBytes (length fields) ++
            tableToBytes  fieldToBytes fields ++
            uint16ToBytes (length methods) ++
            tableToBytes  methodToBytes methods ++
            uint16ToBytes (length attributes) ++
            tableToBytes  attributeToBytes attributes
    }
}

var getInstructionBytes = ins => {
    match ins {
        | JVMiconst_0        -> (i2c 0x03 : [])
        | JVMiconst_1        -> (i2c 0x04 : [])
        | JVMldc i           -> (i2c 0x12 : uint8ToBytes i)
        | JVMldc_w i         -> (i2c 0x13 : uint16ToBytes i)
        | JVMiload i         -> (i2c 0x15 : uint8ToBytes i)
        | JVMaload_0         -> (i2c 0x2A : [])
        | JVMistore i        -> (i2c 0x36 : uint8ToBytes i)
        | JVMiadd            -> (i2c 0x60 : [])
        | JVMisub            -> (i2c 0x64 : [])
        | JVMimul            -> (i2c 0x68 : [])
        | JVMif_icmpeq b     -> (i2c 0x9F : int16ToBytes b)
        | JVMif_icmpne b     -> (i2c 0xa0 : int16ToBytes b)
        | JVMif_icmplt b     -> (i2c 0xA1 : int16ToBytes b)
        | JVMif_icmpgt b     -> (i2c 0xA3 : int16ToBytes b)
        | JVMgoto b          -> (i2c 0xA7 : int16ToBytes b)
        | JVMreturn          -> (i2c 0xB1 : [])
        | JVMgetstatic i     -> (i2c 0xB2 : uint16ToBytes i)
        | JVMinvokevirtual i -> (i2c 0xB6 : uint16ToBytes i)
        | JVMinvokespecial i -> (i2c 0xB7 : uint16ToBytes i)
    }
}

#-------------------------------------------------------------------
#Codegen
#-------------------------------------------------------------------

#todo
var getConstantIndex::(NumeralNode -> (EnvC -> (UInt16, EnvC))) = num => {
    cPool => {
        0
    }
}

#todo
var getVarIndex::(VarNode -> (EnvV -> (UInt16, EnvC))) = num => {
    cPool => {
        0
    }
}

var initialConstantPool = [
    # 1
    MethodRef (5, 12),
    FieldRef (13, 14),
    MethodRef (15, 16),
    ClassRef 17,
    ClassRef 18,
    # 6
    StringConstant "<init>",
    StringConstant "()V",
    StringConstant "Code",
    StringConstant "main",
    StringConstant "([Ljava/lang/String;)V",
    #11
    StringConstant "Main.java",
    NameAndType (6, 7),
    ClassRef 19,
    NameAndType (20, 21),
    ClassRef 22,
    #16
    NameAndType (23, 24),
    StringConstant "Main",
    StringConstant "java/lang/Object",
    StringConstant "java/lang/System",
    StringConstant "out",
    #21
    StringConstant "Ljava/io/PrintStream;",
    StringConstant "java/io/PrintStream",
    StringConstant "println",
    StringConstant "(I)V"
]

var printConstantIndex = 3

var initInstructions = [
    JVMaload_0,
    JVMinvokespecial 1,
    JVMreturn
]

#todo
var initialEnvV = 0
var initialEnvJ = 0

var generateClassFile = ast => {
    0
}

#todo
var updateJVM = s => {
    l => {
        envJ => {
            updateJVME s l 0 envJ
        }
    }
}

#todo
var updateJVME = s => {
    l => {
        c => {
            envJ => {
                0
            }
        }
    }
}

#todo
var genCodeStatement = node => {
    envV => {
        envJ => {
            match node {
                | AssignmentNode (v, a)  -> 0
                | SkipNode               -> 0
                | CompositeNode (s1, s2) -> 0
                | IfNode (b, s1, s2)     -> 0
                | WhileNode (b, s)       -> 0
                | PrintNode (a)          -> 0
            }
        }
    }
}

#todo
var genCodeBoolExpr = node => {
    envV => {
        envJ => {
            match node {
                | ComparisonNode (a1, a2)  -> 0
                | LessThanNode (a1, a2)    -> 0
                | GreaterThanNode (a1, a2) -> 0
                | NotNode b                -> 0
                | AndNode (b1, b2)         -> 0
                | OrNode (b1, b2)          -> 0
                | BoolParenNode a          -> 0
            }
        }
    }
}

#todo
var genCodeArithExpr = node => {
    envV => {
        envJ => {
            match node {
                | NumExprNode n         -> 0
                | VarExprNode v         -> 0
                | AddExprNode (a1, a2)  -> 0
                | SubExprNode (a1, a2)  -> 0
                | MultExprNode (a1, a2) -> 0
                | ArithParenNode a      -> 0
            }
        }
    }
}

var count = i => {
    case {
        | i == 256 -> []
        | ? -> (i2c i : count (i + 1))
    }
}

#test stuff
var bytes = count 0

var bytesback = map c2i bytes

var temp = MethodInfo (
    123,
    1,
    2,
    [CodeAttributeInfo (8, 32, 32, initInstructions, [], [])]
)

var classFile = ClassFile ([1,2,3,4], 0, 49, initialConstantPool, 123, 4, 5, [], [], [temp], [])

var content = getClassBytes classFile
#var content = show initialConstantPool

var main = sys => {
    let (status, sys2, file') = open_write sys "test" in (
        let (status', file) = (writes content file') in (
            close sys2 file
        )
    )
}