#-------------------------------------------------------------------
#Utility types
#-------------------------------------------------------------------

type Maybe<a> = {
    | Just a
    | Nothing
}

type Map<k,v> = {
    | Node (k, v, Map, Map)
    | Nil
}

#-------------------------------------------------------------------
#AST types
#-------------------------------------------------------------------

type NumeralNode = {
    | NumeralNode String
}

type VarNode = {
    | VarNode String
}

type BoolExprNode = {
    | ComparisonNode (ArithExprNode, ArithExprNode)
    | LessThanNode (ArithExprNode, ArithExprNode)
    | GreaterThanNode (ArithExprNode, ArithExprNode)
    | NotNode BoolExprNode
    | AndNode (BoolExprNode, BoolExprNode)
    | OrNode (BoolExprNode, BoolExprNode)
    | BoolParenNode BoolExprNode
}

type ArithExprNode = {
    | NumExprNode NumeralNode
    | VarExprNode VarNode
    | AddExprNode (ArithExprNode, ArithExprNode)
    | MultExprNode (ArithExprNode, ArithExprNode)
    | SubExprNode (ArithExprNode, ArithExprNode)
    | ArithParenNode ArithExprNode
}

type StatementNode = {
    | AssignmentNode (VarNode, ArithExprNode)
    | SkipNode
    | CompositeNode (StatementNode, StatementNode)
    | IfNode (BoolExprNode, StatementNode, StatementNode)
    | WhileNode (BoolExprNode, StatementNode)
    | PrintNode ArithExprNode
}

#-------------------------------------------------------------------
#JVM types
#-------------------------------------------------------------------

#https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.1
type ClassFile = { 
    | ClassFile (
        [Int],          #magicNumber
        Int,            #versionMinor
        Int,            #versionMajor
        [PoolConstant], #constantPool
        Int,            #accessFlags
        Int,            #thisClass
        Int,            #superClass
        [Int],          #interfaces
        [FieldInfo],    #fields
        [MethodInfo],   #methods
        [AttributeInfo] #attributes
    )
}

#https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4
type PoolConstant = { 
    | StringConstant String
    | IntegerConstant Int
    | ClassRef Int
    | StringRef Int
    | FieldRef (Int, Int)
    | MethodRef (Int, Int)
    | NameAndType (Int, Int)
}

#https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.5
type FieldInfo = {
    | FieldInfo (
        Int,            #access flags
        Int,            #name
        Int,            #descriptor
        [AttributeInfo] #attributes
    )
}

#https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.6
type MethodInfo = { 
    | MethodInfo (
        Int,            #access flags
        Int,            #name
        Int,            #descriptor
        [AttributeInfo] #attributes
    )
}

#https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.3
type ExceptionInfo = {
    | ExceptionInfo (
        Int, #start pc
        Int, #end pc
        Int, #handler pc
        Int  #catch type
    )
}

#https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7
#https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7.3
type AttributeInfo = {
    | AttributeInfo (
        Int,  #name
        [Int] #info
    )
    | CodeAttributeInfo (
        Int,              #name
        Int,              #maxStack
        Int,              #maxLocals
        [JVMInstruction], #code
        [ExceptionInfo],  #exceptions
        [AttributeInfo]   #attributes
    )
}

type JVMInstruction = {
    | JVMiconst_0           # Push integer 0 onto stack
    | JVMiconst_1           # Push integer 1 onto stack
    | JVMldc Int            # Push constant from cp onto stack
    | JVMldc_w Int          # Push constant from cp onto stack (wide index)
    | JVMiload Int          # Push integer from local variable onto stack
    | JVMaload_0            # Push reference from cp onto stack
    | JVMistore Int         # Store top of stack to local variable
    | JVMiadd               # Add two numbers on stack
    | JVMisub               # Subtract two numbers on stack
    | JVMimul               # Multiply two numbers on stack
    | JVMif_icmpeq Int      # Jump if equal
    | JVMif_icmpne Int      # Jump if not equal
    | JVMif_icmplt Int      # Jump if less than
    | JVMif_icmpgt Int      # Jump if greater than
    | JVMgoto Int           # Jump to
    | JVMreturn             # Return from method
    | JVMgetstatic Int      # Push static field onto stack
    | JVMinvokevirtual Int  # Invoke virtual method
    | JVMinvokespecial Int  # Invoke special method (used for constructor)
}

type EnvC = {
    | EnvC (Map<String, Int>, [PoolConstant], Int)
}

type EnvJVM = {
    | EnvJVM (Int, Int, Int, EnvC)
}

type EnvV = {
    | EnvV (Map<String, Int>, Int)
}

#-------------------------------------------------------------------
#Utility functions
#-------------------------------------------------------------------

var max::(Int -> (Int -> Int)) =
a::Int => {
    b::Int => {
        case {
            | a > b -> a
            | ?     -> b
        }
    }
}


var bind::(Map<k,v> -> (k -> (v -> Map<k,v>))) = 
map::Map<k,v> => {
    key::k => {
        value::v => {
            match map {
                | Nil -> Node (key, value, Nil, Nil)
                | Node (key', value', map1', map2') -> 
                case {
                    | key == key' -> Node (key, value, map1', map2')
                    | key < key'  -> Node (key', value', (bind map1' key value), map2')
                    | key > key'  -> Node (key', value', map1', (bind map2' key value))
                }
            }
        } 
    }
}

var lookup::(Map<k,v> -> (k -> Maybe<v>)) = 
map::Map<k,v> => {
    key::k => {
        match map {
            | Nil -> Nothing
            | Node (key', value', map1', map2') ->
            case {
                | key == key' -> Just value'
                | key < key'  -> lookup map1' key
                | key > key'  -> lookup map2' key
            }
        }
    }
}

var writes::(String -> (File* -> (Bool, File*))) = 
s::String => {
    f::File* => {
        match s {
            | []     -> (true, f)
            | (c:cs) -> 
                let (succ, f') = write c f in (
                    case {
                    | succ == true -> (writes cs f')
                    | ?            -> (false, f') 
                }
            )
        }
    }
}

var writeFile::(String -> ([Char] ->  (System* -> (Bool, System*)))) =
path::String => {
    bytes::[Char] => {
        sys::System* => {
            let (status2, sys2, file') = open_write sys path in (
                case {
                    | status2 == false -> (false, sys2)  #check open error
                    | ? -> let (status', file) = writes content file' in (
                        case {
                            | status' == false -> (false, sys2)  #check write error
                            | ? -> close sys2 file
                        }
                    )
                }
            )
        }
    }
}

var length::([a] -> Int) = 
l::[a] => {
    match l {
        | []     -> 0
        | (c:cs) -> 1 + length cs
    }
}

var map::((a -> b) -> ([a] -> [b])) = 
fun::(a -> b) => {
    lst::[a] => {
        match lst {
            | [] -> []
            | (x:xs) -> ((fun x) : (map fun xs))
        }
    }
}

var concat::([[a]] -> [a]) = 
lst::[[a]] => {
    match lst {
        | [] -> []
        | (x:xs) -> x ++ (concat xs) 
    }
}

#-------------------------------------------------------------------
#JVM
#-------------------------------------------------------------------

var getByte::(Int -> (Int -> Char)) = 
b::Int => {
    num::Int => {
        i2c (num b>> (8 * b) b& 0xFF)
    }
}

var getBytes::(Int -> (Int -> [Char])) = 
c::Int => {
    num::Int => {
        case {
            | c == 0 -> []
            | ? -> (getByte (c - 1) num : getBytes (c - 1) num)
        }
    }
}

var uint8ToBytes::(Int -> [Char]) = getBytes 1
var uint16ToBytes::(Int -> [Char]) = getBytes 2
var uint32ToBytes::(Int -> [Char]) = getBytes 4

var int16ToBytes::(Int -> [Char]) = uint16ToBytes

var tableToBytes::((a -> [Char]) -> ([a] -> [Char])) = 
f::(a -> [Char]) => { 
    l::[a] => { concat (map f l) }
}

var poolConstantToBytes::(PoolConstant -> [Char]) = 
pc::PoolConstant => {
    match pc {
        | StringConstant str     -> uint8ToBytes  1 ++ uint16ToBytes (length str) ++ str
        | IntegerConstant i      -> uint8ToBytes  3 ++ uint32ToBytes i
        | ClassRef si            -> uint8ToBytes  7 ++ uint16ToBytes si
        | StringRef si           -> uint8ToBytes  8 ++ uint16ToBytes si
        | FieldRef (c, ntd)      -> uint8ToBytes  9 ++ uint16ToBytes c ++ uint16ToBytes ntd
        | MethodRef (c, ntd)     -> uint8ToBytes 10 ++ uint16ToBytes c ++ uint16ToBytes ntd
        | NameAndType (nsi, tdi) -> uint8ToBytes 12 ++ uint16ToBytes nsi ++ uint16ToBytes tdi
    }
}

#todo last
var fieldToBytes::(FieldInfo -> [Char]) = 
field::FieldInfo => {
    []
}


var methodToBytes::(MethodInfo -> [Char]) = 
method::MethodInfo => {
    match method {
        | MethodInfo (accessFlags, name, descriptor, attributes) ->
            uint16ToBytes accessFlags ++
            uint16ToBytes name ++
            uint16ToBytes descriptor ++
            uint16ToBytes (length attributes) ++
            tableToBytes attributeToBytes attributes
    }
}

var attributeToBytes::(AttributeInfo -> [Char]) = 
attribute::AttributeInfo => {
    match attribute {
        | AttributeInfo (name, info) -> [] #todo last
        | CodeAttributeInfo (name, maxStack, maxLocals, code, exceptions, attributes) ->
            let codeBytes = tableToBytes getInstructionBytes code in (
                uint16ToBytes name ++
                uint32ToBytes (
                    12 +
                    length codeBytes +
                    length exceptions +
                    length attributes
                ) ++
                uint16ToBytes maxStack ++
                uint16ToBytes maxLocals ++
                uint32ToBytes (length codeBytes) ++
                codeBytes ++
                uint16ToBytes (length exceptions) ++
                tableToBytes exceptionToBytes exceptions ++
                uint16ToBytes (length attributes) ++
                tableToBytes attributeToBytes attributes
            )
    }
}

#todo last
var exceptionToBytes::(ExceptionInfo -> [Char]) = 
exception::ExceptionInfo => {
    []
}


var getClassBytes::(ClassFile -> [Char]) = 
class::ClassFile => {
    match class {
        | ClassFile (magicNumber, versionMinor, versionMajor, constantPool, accessFlags, 
        thisClass, superClass, interfaces, fields, methods, attributes) ->
            tableToBytes  uint8ToBytes magicNumber ++
            uint16ToBytes versionMinor ++
            uint16ToBytes versionMajor ++
            uint16ToBytes ((length constantPool) + 1) ++
            tableToBytes  poolConstantToBytes constantPool ++
            uint16ToBytes accessFlags ++
            uint16ToBytes thisClass ++
            uint16ToBytes superClass ++
            uint16ToBytes (length interfaces) ++
            tableToBytes  uint16ToBytes interfaces ++
            uint16ToBytes (length fields) ++
            tableToBytes  fieldToBytes fields ++
            uint16ToBytes (length methods) ++
            tableToBytes  methodToBytes methods ++
            uint16ToBytes (length attributes) ++
            tableToBytes  attributeToBytes attributes
    }
}

var getInstructionBytes::(JVMInstruction -> [Char]) = 
ins::JVMInstruction => {
    match ins {
        | JVMiconst_0        -> (i2c 0x03 : [])
        | JVMiconst_1        -> (i2c 0x04 : [])
        | JVMldc i           -> (i2c 0x12 : uint8ToBytes i)
        | JVMldc_w i         -> (i2c 0x13 : uint16ToBytes i)
        | JVMiload i         -> (i2c 0x15 : uint8ToBytes i)
        | JVMaload_0         -> (i2c 0x2A : [])
        | JVMistore i        -> (i2c 0x36 : uint8ToBytes i)
        | JVMiadd            -> (i2c 0x60 : [])
        | JVMisub            -> (i2c 0x64 : [])
        | JVMimul            -> (i2c 0x68 : [])
        | JVMif_icmpeq b     -> (i2c 0x9F : int16ToBytes b)
        | JVMif_icmpne b     -> (i2c 0xA0 : int16ToBytes b)
        | JVMif_icmplt b     -> (i2c 0xA1 : int16ToBytes b)
        | JVMif_icmpgt b     -> (i2c 0xA3 : int16ToBytes b)
        | JVMgoto b          -> (i2c 0xA7 : int16ToBytes b)
        | JVMreturn          -> (i2c 0xB1 : [])
        | JVMgetstatic i     -> (i2c 0xB2 : uint16ToBytes i)
        | JVMinvokevirtual i -> (i2c 0xB6 : uint16ToBytes i)
        | JVMinvokespecial i -> (i2c 0xB7 : uint16ToBytes i)
    }
}

#-------------------------------------------------------------------
#Codegen
#-------------------------------------------------------------------

var getConstantIndex::(NumeralNode -> (EnvC -> (Int, EnvC))) = 
numNode::NumeralNode => {
    cPool::EnvC => {
        match (numNode, cPool) {
            | (NumeralNode numS, EnvC (indexMap, elements, poolSize)) ->
                match (lookup indexMap numS)  {
                    | Nothing -> (
                        poolSize + 1, EnvC (
                            bind indexMap numS poolSize,
                            let (?, num) = to_int numS in (
                                elements ++ [IntegerConstant num]
                            ),
                            poolSize + 1
                        )
                    )
                    | Just index -> (index + 1, cPool)
                }
        }
    }
}

var getVarIndex::(VarNode -> (EnvV -> (Int, EnvV, Bool))) = 
varNode::VarNode => {
    varEnv::EnvV => {
        match (varNode, varEnv) {
            | (VarNode vari, EnvV (indexMap, varCount)) ->
                match lookup indexMap vari {
                    | Nothing -> (
                            varCount + 1, EnvV (
                                bind indexMap vari varCount,
                                varCount + 1
                            ),
                            false
                        )
                    | Just index -> (index + 1, varEnv, true)
                }
        }
    }
}

var initialConstantPool::[PoolConstant] = [
    # 1
    MethodRef (5, 12),
    FieldRef (13, 14),
    MethodRef (15, 16),
    ClassRef 17,
    ClassRef 18,
    # 6
    StringConstant "<init>",
    StringConstant "()V",
    StringConstant "Code",
    StringConstant "main",
    StringConstant "([Ljava/lang/String;)V",
    #11
    StringConstant "Main.java",
    NameAndType (6, 7),
    ClassRef 19,
    NameAndType (20, 21),
    ClassRef 22,
    #16
    NameAndType (23, 24),
    StringConstant "Main",
    StringConstant "java/lang/Object",
    StringConstant "java/lang/System",
    StringConstant "out",
    #21
    StringConstant "Ljava/io/PrintStream;",
    StringConstant "java/io/PrintStream",
    StringConstant "println",
    StringConstant "(I)V"
]

var printConstantIndex::Int = 3

var initInstructions::[JVMInstruction] = [
    JVMaload_0,
    JVMinvokespecial 1,
    JVMreturn
]

var initialEnvV::EnvV = EnvV (Nil, 0)
var initialEnvJ::EnvJVM = EnvJVM (2, 1, 1, EnvC (Nil, initialConstantPool, length initialConstantPool))

#generateClassFile :: StatementNode -> ClassFile
#generateClassFile ast =
#    let (ins, _, _, (_, maxStack, maxLocals, (_, cPool, _))) = genCodeStatement ast initialEnvV initialEnvJ in ClassFile 
#        [0xCA, 0xFE, 0xBA, 0xBE] -- magic number
#        0       -- version minor
#        49      -- version major
#        cPool
#        0x0000  -- access flags
#        4       -- this class (Main)
#        5       -- super class (java/lang/Object)
#        []      -- interfaces 
#        []      -- fields
#        [ (MethodInfo 0x0001 6 7 [(CodeAttributeInfo 8 1 1 initInstructions [] [])]), -- <init> method
#          (MethodInfo 0x0009 9 10 [(CodeAttributeInfo 8 maxStack maxLocals (ins ++ [JVMreturn]) [] [])]) ] -- main method
#        []      --attributes

var generateClassFile::(StatementNode -> ClassFile) = 
ast::StatementNode => {
    match genCodeStatement ast initialEnvV initialEnvJ {
        | (ins, ?, ?, EnvJVM (?, maxStack, maxLocals, EnvC (?, cPool, ?))) -> 
            ClassFile (
                [0xCA, 0xFE, 0xBA, 0xBE], # magic number
                0,      # version minor
                49,     # version major
                cPool,
                0x0000, # access flags
                4,      # this class (Main)
                5,      # super class (java/lang/Object)
                [],     # interfaces 
                [],     # fields
                [ (MethodInfo (0x0001, 6, 7, [(CodeAttributeInfo (8, 1, 1, initInstructions, [], []))])), # <init> method
                  (MethodInfo (0x0009, 9, 10, [(CodeAttributeInfo (8, maxStack, maxLocals, (ins ++ [JVMreturn]), [], []))])) ], # main method
                []      # attributes
            )
    }
}

var updateJVM::(Int -> (Int -> (EnvJVM -> EnvJVM))) = 
s::Int => {
    l::Int => {
        envJ::EnvJVM => {
            match envJ {
                | EnvJVM (?, ?, ?, envC) ->
                    updateJVME s l envC envJ
            }
        }
    }
}

var updateJVME::(Int -> (Int -> (EnvC -> (EnvJVM -> EnvJVM)))) = 
s::Int => {
    l::Int => {
        c::EnvC => {
            envJ::EnvJVM => {
                match envJ {
                    | EnvJVM (curStack, maxStack, maxLocals, ?) ->
                        EnvJVM (curStack + s, max curStack maxStack, maxLocals + l, c)
                }
            }
        }
    }
}

var genCodeStatement::(StatementNode -> (EnvV -> (EnvJVM -> ([JVMInstruction], Int, EnvV, EnvJVM)))) = 
node::StatementNode => {
    envV::EnvV => {
        envJ::EnvJVM => {
            match node {
                | AssignmentNode (v, a)  -> 
                    let (aIns, aInsSize, envJ') = genCodeArithExpr a envV envJ in (
                        let (index, envV', present) = getVarIndex v envV in (
                            ( aIns ++ [JVMistore index]
                            , aInsSize + 2
                            , envV'
                            , case {
                                | present == true -> envJ' 
                                | ?               -> updateJVM 0 1 envJ'
                              }
                            )
                        )
                    )
                | SkipNode -> ([], 0, envV, envJ)
            #    | CompositeNode (s1, s2) -> 0 #todo
            #    | IfNode (b, s1, s2)     -> 0 #todo
            #    | WhileNode (b, s)       -> 0 #todo
            #    | PrintNode (a)          -> 0 #todo
            }
        }
    }
}

var genCodeBoolExpr::(BoolExprNode -> (EnvV -> (EnvJVM -> ([JVMInstruction], Int, EnvJVM)))) = 
node::BoolExprNode => {
    envV::EnvV => {
        envJ::EnvJVM => {
            match node {
            #    | ComparisonNode (a1, a2)  -> 0 #todo
            #    | LessThanNode (a1, a2)    -> 0 #todo
            #    | GreaterThanNode (a1, a2) -> 0 #todo
            #    | NotNode b                -> 0 #todo
            #    | AndNode (b1, b2)         -> 0 #todo
            #    | OrNode (b1, b2)          -> 0 #todo
                | BoolParenNode a          -> genCodeBoolExpr a envV envJ
            }
        }
    }
}

var genCodeArithExpr::(ArithExprNode -> (EnvV -> (EnvJVM -> ([JVMInstruction], Int, EnvJVM)))) = 
node::ArithExprNode => {
    envV::EnvV => {
        envJ::EnvJVM => {
            match node {
                #| NumExprNode n         -> 0
                #| VarExprNode v         -> 0
                #| AddExprNode (a1, a2)  -> 0
                #| SubExprNode (a1, a2)  -> 0
                #| MultExprNode (a1, a2) -> 0
                | ArithParenNode a      -> genCodeArithExpr a envV envJ
            }
        }
    }
}

var program::StatementNode = SkipNode

var bytes::[Char] = getClassBytes (generateClassFile program)

var main::(System* -> (Bool, System*)) = 
sys::System* => {
    writeFile "Main.class" bytes sys
}

#test stuff
var temp::MethodInfo = MethodInfo (
    123,
    1,
    2,
    [CodeAttributeInfo (8, 32, 32, initInstructions, [], [])]
)

var classFile::ClassFile = ClassFile ([1,2,3,4], 0, 49, initialConstantPool, 123, 4, 5, [], [], [temp], [])

#var content = getClassBytes classFile
var content::[Char] = bytes


#var main::(System* -> (Bool, File*)) = 
#sys::System* => {
#    let envJ = updateJVME 0 0 (EnvC (Nil, initialConstantPool ++ [IntegerConstant 42], 25)) initialEnvJ in (
#        writes (show envJ) stdout
#    )
#}